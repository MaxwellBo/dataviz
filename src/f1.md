# F1

```js
const positions = await FileAttachment("f1.json").json();
// const positions2 = await FileAttachment("f1.parquet").parquet();

display(positions)
// Transform the data into a more reasonable structure
const intermediate = Object.keys(positions.X).map(key => ({
  date: positions.Date[key],
  status: positions.Status[key],
  x: positions.X[key],
  y: positions.Y[key],
  source: positions.Source[key],
  time: positions.Time[key],
  driverAhead: positions.DriverAhead[key],
  distanceToDriverAhead: positions.DistanceToDriverAhead[key],
  sessionTime: positions.SessionTime[key],
  driver: positions.DriverId[key],
  eventName: positions.EventName[key],
  // driverName: positions.FullName[key]
}));
```

```js
const distance = view(
  Inputs.range([0, 5],
    {step: 0.1, label: "Distance"}
  )
);
```


```js
const tidy = intermediate.filter(d => d.distanceToDriverAhead <= distance)
display(tidy)
Inputs.table(tidy)
```


Plot the positions
```js
Plot.plot({
  color: {
    scheme: "viridis",
  },
  marks: [
    Plot.dot(tidy, Plot.hexbin({fill: "count" }, {x: "x", y: "y", binWidth: 5, fx: "eventName" })),
    ]
})
```

<!-- ```js
Plot.plot({
  color: {
    scheme: "viridis",
  },
  aspectRatio: 1,
  marks: [
    Plot.rect(tidy, Plot.bin({fill: "count", thresholds: 50,  }, {x: "x", y: "y", fy: "eventName" }))
  ]
})
``` -->

Plot the positions


```js
function plotCircuit(eventName) {
  return Plot.plot({
    color: {
      scheme: "viridis",
    },
    aspectRatio: 1,
    marks: [
      Plot.dot(tidy.filter(d => d.eventName === eventName), Plot.hexbin({fill: "count" }, {x: "x", y: "y" }))
    ]
  })
}
```

```js
const eventNames = [...new Set(tidy.map(d => d.eventName))];
```

```js
const content = htl.html`
  <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px;">
    ${eventNames.map(event => htl.html`
      <div>
        <h3>${event}</h3>
        ${plotCircuit(event)}
      </div>
    `)}
  </div>
`;

display(content);
```


Plot the driver ahead by time
```js
Plot.plot({
  marks: [Plot.line(tidy, {x: "sessionTime", y: "distanceToDriverAhead", stroke: "driver", fy: "eventName"})]
})
```

Whenever the driver ahead changes, mark the change location on map

```js
Plot.plot({
  marks: [Plot.dot(tidy, {x: "time", y: "y", fill: "driver", fy: "driver", fx: "eventName" })]
})
```


Use an inputs slider to scrub to a specific time stamp, plot all the drivers on the map
```js
const time = view(Inputs.range([0, 100000], {step: 1, label: "Time", value: 0}))
```
```js
// const p = tidy.filter(d => time <= d.time && d.time <= time + 20000)

Plot.plot({
  marks: [Plot.dot(tidy, {
    x: "x", 
    y: "y", 
    fill: "driver",
    fy: "eventName",
    filter: d => time <= d.time && d.time <= time + 1000
   })]
})
```