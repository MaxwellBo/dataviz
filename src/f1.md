# F1

```js
const positions = await FileAttachment("f1.json").json();
// const positions2 = await FileAttachment("f1.parquet").parquet();

display(positions)
// Transform the data into a more reasonable structure
const intermediate = Object.keys(positions.X).map(key => ({
  date: positions.Date[key],
  status: positions.Status[key],
  x: positions.X[key],
  y: positions.Y[key],
  source: positions.Source[key],
  time: positions.Time[key],
  driverAhead: positions.DriverAhead[key],
  distanceToDriverAhead: positions.DistanceToDriverAhead[key],
  sessionTime: positions.SessionTime[key],
  driver: positions.DriverId[key],
  eventName: positions.EventName[key],
  // driverName: positions.FullName[key]
}));
```

```js
const distance = view(
  Inputs.range([0, 5],
    {step: 0.1, label: "Distance"}
  )
);
```


```js
const tidy = intermediate.filter(d => d.distanceToDriverAhead <= distance)
display(tidy)
Inputs.table(tidy)
```


Plot the positions
```js
Plot.plot({
  color: {
    scheme: "viridis",
  },
  fx: {
    domain: ["Bahrain Grand Prix", "Australian Grand Prix", "Saudi Arabian Grand Prix"],
  },
  marks: [Plot.dot(tidy, Plot.hexbin({fill: "count" }, {x: "x", y: "y", binWidth: 5, fx: "eventName" }))]
})
```

<!-- ```js
Plot.plot({
  color: {
    scheme: "viridis",
  },
  aspectRatio: 1,
  marks: [
    Plot.rect(tidy, Plot.bin({fill: "count", thresholds: 50,  }, {x: "x", y: "y", fy: "eventName" }))
  ]
})
``` -->

Plot the positions
```js
Plot.plot({
  color: {
    scheme: "viridis",
  },
  aspectRatio: 1,
  marks: [
    Plot.dot(tidy.filter(d => d.eventName === "Bahrain Grand Prix"), Plot.hexbin({fill: "count", }, {x: "x", y: "y" }))
  ]
})
```

```js
Plot.plot({
  color: {
    scheme: "viridis",
  },
  aspectRatio: 1,
  marks: [
    Plot.dot(tidy.filter(d => d.eventName === "Australian Grand Prix"), Plot.hexbin({fill: "count" }, {x: "x", y: "y" }))
  ]
})
```

```js
Plot.plot({
  color: {
    scheme: "viridis",
  },
  aspectRatio: 1,
  marks: [
    Plot.dot(tidy.filter(d => d.eventName === "Saudi Arabian Grand Prix"), Plot.hexbin({fill: "count" }, {x: "x", y: "y", fy:"eventName" }))
  ]
})
```

Plot heatmap using a really small binsize



Plot the driver ahead by time
```js
Plot.plot({
  marks: [Plot.line(tidy, {x: "sessionTime", y: "distanceToDriverAhead", stroke: "driver", fy: "eventName"})]
})
```

Whenever the driver ahead changes, mark the change location on map

```js
Plot.plot({
  marks: [Plot.dot(tidy, {x: "time", y: "y", fill: "driver", fy: "driver", fx: "eventName" })]
})
```


Use an inputs slider to scrub to a specific time stamp, plot all the drivers on the map
```js
const time = view(Inputs.range([0, 100000], {step: 1, label: "Time", value: 0}))
```
```js
// const p = tidy.filter(d => time <= d.time && d.time <= time + 20000)

Plot.plot({
  marks: [Plot.dot(tidy, {
    x: "x", 
    y: "y", 
    fill: "driver",
    fy: "eventName",
    filter: d => time <= d.time && d.time <= time + 1000
   })]
})
```